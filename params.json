{"name":"Objection","tagline":"A lightweight dependency injection framework for Objective-C","body":"[![Build Status](https://travis-ci.org/atomicobject/objection.png)](https://travis-ci.org/atomicobject/objection)\r\n\r\n## Description\r\n\r\nObjection is a lightweight dependency injection framework for Objective-C for MacOS X and iOS. For those of you that have used [Guice](http://code.google.com/p/google-guice/), Objection will feel familiar. Objection was built to stay out of your way and alleviate the need to maintain a large XML container or manually construct objects.\r\n\r\n## Features\r\n\r\n* \"Annotation\" Based Dependency Injection\r\n* Seamless support for integrating custom and external dependencies\r\n  * Custom Object Providers\r\n  * Meta Class Bindings\r\n  * Protocol Bindings\r\n  * Instance Bindings\r\n* Lazily instantiates dependencies\r\n* Eager Singletons\r\n* Initializer Support\r\n  * Default and custom arguments\r\n\r\n## Using Objection\r\n\r\nFor questions, visit the [mailing list](https://groups.google.com/forum/?fromgroups#!forum/objection-framework)\r\n### Basic Usage\r\n\r\nA class can be registered with objection using the macros *objection_register* (optional) or *objection_register_singleton*. The *objection_requires* macro can be used to declare what dependencies objection should provide to all instances it creates of that class. *objection_requires* can be used safely with inheritance.\r\n\r\n#### Example\r\n```objective-c\r\n@class Engine, Brakes;\r\n\r\n@interface Car : NSObject\r\n{\r\n  Engine *engine;\r\n  Brakes *brakes;\r\n  BOOL awake;  \r\n}\r\n\r\n// Will be filled in by objection\r\n@property(nonatomic, strong) Engine *engine;\r\n// Will be filled in by objection\r\n@property(nonatomic, strong) Brakes *brakes;\r\n@property(nonatomic) BOOL awake;\r\n\r\n@implementation Car\r\nobjection_requires(@\"engine\", @\"brakes\")\r\n@synthesize engine, brakes, awake;\r\n@end\r\n```\r\n#### Defining dependencies with selectors\r\n\r\nYou can alternatively use selectors to define dependencies. The compiler will generate a warning if a given selector is not visible or cannot be found.\r\n\r\n#### Example\r\n\r\n```objective-c\r\n@implementation Car\r\nobjection_requires_sel(@selector(engine), @selector(brakes))\r\n@synthesize engine, brakes, awake;\r\n@end\r\n```\r\n\r\n### Fetching Objects from Objection\r\n\r\nAn object can be fetched from objection by creating an injector and then asking for an instance of a particular class or protocol. An injector manages its own object context. Which means that a singleton is per injector and is not necessarily a *true* singleton.\r\n\r\n```objective-c\r\n- (void)someMethod {\r\n  JSObjectionInjector *injector = [JSObjection createInjector];\r\n  id car = [injector getObject:[Car class]];\r\n}\r\n```\r\n\r\nA default injector can be registered with Objection which can be used throughout your application or library.\r\n\r\n```objective-c    \r\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    \r\n  JSObjectionInjector *injector = [JSObjection createInjector];\r\n  [JSObjection setDefaultInjector:injector];\r\n}\r\n\r\n- (void)viewDidLoad {\r\n  id myModel = [[JSObjection defaultInjector] getObject:[MyModel class]];\r\n}\r\n```\r\n\r\n#### Injecting dependencies\r\n\r\nThere may be instances where an object is allocated outside of the injector's life cycle. If the object's class declared its dependencies using *objection_requires* an injector can satisfy its dependencies via the *injectDependencies:* method.\r\n\r\n```objective-c\r\n@implementation JSTableModel\r\nobjection_requires(@\"RESTClient\")\r\n- (void)awakeFromNib {\r\n  [[JSObjection defaultInjector] injectDependencies:self];\r\n}\r\n@end\r\n```\r\n\r\n#### Subscripting\r\n\r\nObjection has support for the subscripting operator to retrieve objects from the injection context.\r\n\r\n```objective-c\r\n- (void)someMethod {\r\n  JSObjectionInjector *injector = [JSObjection createInjector];\r\n  id car = injector[[Car class]];\r\n}\r\n```\r\n\r\n### Awaking from Objection\r\n\r\nIf an object is interested in knowing when it has been fully instantiated by objection it can implement the method\r\n*awakeFromObjection*.\r\n\r\n#### Example\r\n```objective-c\r\n@implementation Car\r\n//...\r\nobjection_register_singleton(Car)\r\n  - (void)awakeFromObjection {\r\n    awake = YES;\r\n  }\r\n@end  \r\n```  \r\n\r\n### Object Factory\r\n\r\nA class can get objects from the injector context through an object factory.\r\n\r\n### Example\r\n```objective-c\r\n@interface RequestDispatcher\r\n@property(nonatomic, strong) JSObjectFactory *objectFactory\r\n@end\r\n\r\n@implementation RequestDispatcher\r\n- (void)dispatch:(NSDictionary *)params\r\n{\r\n  Request *request = [self.objectFactory getObject:[Request class]];\r\n  request.params = params;\r\n  [request send];\r\n}\r\n@end\r\n```\r\n## Modules\r\n\r\nA module is a set of bindings which contributes additional configuration information to the injector. It is especially useful for integrating external depencies and binding protocols to classes or instances.\r\n\r\n#### Instance and Protocol Bindings\r\n\r\n* Bind a protocol or class to a specific instance of that type\r\n* Bind a class that is registered with Objection to a protocol\r\n\r\n#### Example\r\n```objective-c\r\n@interface MyAppModule : JSObjectionModule {\r\n  \r\n}\r\n@end\r\n\r\n@implementation MyAppModule\r\n- (void)configure {\r\n  [self bind:[UIApplication sharedApplication] toClass:[UIApplication class]];\r\n  [self bind:[UIApplication sharedApplication].delegate toProtocol:@protocol(UIApplicationDelegate)];\r\n  [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];\r\n}\r\n\r\n@end\r\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    \r\n  JSObjectionInjector *injector = [JSObjection createInjector:[[MyAppModule alloc] init]];\r\n  [JSObjection setDefaultInjector:injector];\r\n}\r\n```\r\n#### Meta Class Bindings\r\n\r\nThere are times when a dependency -- usually external -- is implemented using only class methods. Objection can explicitly support binding to\r\nthe meta class instance through a protocol. This avoids having to unnecessarily create a wrapper class that passes through to the class\r\nmethods. The catch, of course, is that it requires a protocol definition so that Objection knows how to bind the meta class to objects\r\nin the injector context.\r\n\r\n#### Example\r\n```objective-c\r\n@protocol ExternalUtility\r\n  - (void)doSomething;\r\n@end\r\n\r\n@interface ExternalUtility\r\n  + (void)doSomething;\r\n@end\r\n\r\n@implementation ExternalUtility\r\n  + (void)doSomething {...}\r\n@end\r\n\r\n// Module Configuration\r\n- (void)configure {\r\n  [self bindMetaClass:[ExternalUtility class] toProtocol:@protocol(ExternalUtility)];    \r\n}\r\n\r\n@interface SomeClass\r\n{\r\n  ...\r\n}\r\n// Use 'assign' because a meta class is not subject to the normal retain/release lifecycle. \r\n// It will exist until the application is terminated (Class Initialization -> Application Termination)\r\n// regardless of the number of objects in the runtime that reference it.\r\n@property (nonatomic, assign) id<ExternalUtility> externalUtility\r\n@end\r\n```\r\n#### Providers\r\n\r\nOccasionally you'll want to manually construct an object within Objection. Providers allow you to use a custom mechanism for building objects that are bound to a type. You can create a class that _conforms_ to the ObjectionProvider protocol or you can use a _block_ to build the object.\r\n      \r\n#### Example\r\n```objective-c\r\n@implementation CarProvider\r\n- (id)provide:(JSObjectionInjector *)context {\r\n  // Manually build object\r\n  return car;\r\n}\r\n@end\r\n\r\n@implementation MyAppModule\r\n- (void)configure {\r\n    [self bindProvider:[[CarProvider alloc] init] toClass:[Car class]];\r\n    [self bindBlock:^(JSObjectionInjector *context) {\r\n      // Manually build object\r\n      return car;          \r\n    } toClass:[Car class]];\r\n}\r\n@end\r\n```\r\n\r\n### Scopes\r\n\r\nA class can be scoped as a singleton in a module. Conversely, a registered singleton can be demoted to a normal lifecycle with in the injector's context.\r\n\r\n### Example\r\n```objective-c\r\n@implementation MyAppModule\r\n- (void)configure {\r\n    [self bindClass:[Singleton class] inScope:JSObjectionScopeNormal];\r\n    [self bindClass:[Car class] inScope:JSObjectionScopeSingleton];\r\n}\r\n@end\r\n```\r\n\r\n### Eager Singletons\r\n\r\nYou can mark registered singleton classes as eager singletons. Eager singletons will be instantiated during the creation of the injector rather than being lazily instantiated.\r\n\r\n### Example\r\n```objective-c\r\n@implementation MyAppModule\r\n- (void)configure {\r\n  [self registerEagerSingleton:[Car class]];\r\n}\r\n\r\n@end\r\n```  \r\n\r\n### Deriving a new injector from an existing injector\r\n\r\nA new injector can be created from an existing injector using the *withModule:* method. A new injector will be created containing the same bindings as the injector it was derived from. The new injector will also contain additional bindings provided by the new module. \r\n\r\nConversley, if *withoutModuleOfType:* is used the new injector will _not_ contain the bindings of the removed module.\r\n\r\n### Example\r\n```objective-c\r\ninjector = [otherInjector withModule:[[Level18Module alloc] init]] \r\n                          withoutModuleOfType:[Level17Module class]];\r\n                          \r\n```\r\n\r\n## Initializers\r\n\r\nBy default, Objection allocates objects with the default initializer <code>init</code>. If you'd like to instantiate an object with an alternate ininitializer the <code>objection_initializer</code> macro can be used to do so. The macro supports passing in default arguments (scalar values are not currently supported) as well.\r\n      \r\n#### Default Arguments Example\r\n```objective-c\r\n@implementation ViewController\r\nobjection_initializer(initWithNibName:bundle:, @\"ViewController\")\r\n@end\r\n```\r\n\r\n####  Custom Arguments Example\r\n```objective-c\r\n@implementation ConfigurableCar\r\nobjection_requires(@\"engine\", @\"brakes\")\r\nobjection_initializer(initWithMake:model:)\r\n\r\n@synthesize make;\r\n@synthesize model;\r\n\r\n- (id)initWithMake:(NSString *)make model:(NSString *)model {\r\n  ...\r\n}\r\n@end\r\n\r\n- (void)buildCar {\r\n  ConfigurableCar *car = [self.objectFactory getObjectWithArgs:[ConfigurableCar class], @\"VW\", @\"Passat\", nil];\r\n  NSLog(@\"Make: %@ Model: %@\", car.make, car.model);\r\n}\r\n```\r\n\r\n## TODO\r\n\r\n* Add a motivation section that speaks to _why_ Objection was created\r\n\r\n## Installation\r\n\r\n### Static Framework and Linkable Framework\r\n\r\nIt can be downloaded [here](http://objection-framework.org/files/Objection-1.2.tar.gz)\r\n\r\n### Building Static Framework\r\n\r\n    git clone git://github.com/atomicobject/objection.git\r\n    git checkout 1.2\r\n    \r\n#### iOS\r\n\r\n\r\n1. rake artifact:ios\r\n2. cp -R build/Release-iphoneuniversal/Objection-iOS.framework ${DEST_DIR}\r\n3. In XCode -> Project Icon -> Your Target -> Build Phases -> Link Binary With Libraries -> Add (+) -> Add Other\r\n4. Add -ObjC and -all_load to Other Link Flags in your project\r\n\r\n#### Include framework\r\n    #import <Objection-iOS/Objection.h>\r\n\r\n#### MacOS X\r\n\r\n1. rake artifact:osx\r\n2. cp -R build/Release/Objection.framework ${DEST_DIR}\r\n3. In XCode -> Project Icon -> Your Target -> Build Phases -> Link Binary With Libraries -> Add (+) -> Add Other\r\n\r\n#### Include framework\r\n    #import <Objection/Objection.h>\r\n\r\n### CocoaPods\r\n\r\nEdit your Pofile\r\n\r\n    edit Podfile\r\n    pod 'Objection', '1.2'\r\n\r\nNow you can install Objection\r\n    \r\n    pod install\r\n\r\nLearn more at [CocoaPods](http://cocoapods.org).\r\n\r\n### Ruby Motion\r\n\r\nA companion library for Objection was created called [motion-objection](https://github.com/atomicobject/motion-objection)\r\n\r\n```bash\r\ngem install motion-objection\r\n```\r\n\r\n## Requirements\r\n\r\n* MacOS X 10.7 +\r\n* iOS 5.0 +\r\n\r\n## Authors\r\n\r\n* Justin DeWind (dewind@atomicobject.com, @dewind on Twitter)\r\n* Â© 2013 [Atomic Object](http://www.atomicobject.com/)\r\n* More Atomic Object [open source](http://www.atomicobject.com/pages/Software+Commons) projects\r\n\r\n## Applications that use Objection\r\n\r\n* [Bubble Island](http://www.wooga.com/games/bubble-island/)\r\n* [Monster World](http://www.wooga.com/games/monster-world/)\r\n* [Pocket Village](http://www.wooga.com/games/pocket-village/)\r\n* [SideReel](https://itunes.apple.com/us/app/sidereel/id417270961?mt=8)\r\n\r\n","google":"UA-37330760-1","note":"Don't delete this file! It's used internally to help with page regeneration."}